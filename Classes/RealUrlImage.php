<?php

/**
 * Main class
 *
 * @author Tim LochmÃ¼ller
 */

namespace FRUIT\FlRealurlImage;

use FRUIT\FlRealurlImage\Event\FileCacheEvent;
use Psr\EventDispatcher\EventDispatcherInterface;
use TYPO3\CMS\Core\Core\Environment;
use TYPO3\CMS\Core\Charset\CharsetConverter;
use TYPO3\CMS\Core\Cache\Frontend\FrontendInterface;
use TYPO3\CMS\Core\Cache\Exception\NoSuchCacheException;
use FRUIT\FlRealurlImage\Provider\AbstractProvider;
use FRUIT\FlRealurlImage\Provider\FalMetaProvider;
use FRUIT\FlRealurlImage\Provider\FalProvider;
use FRUIT\FlRealurlImage\Provider\FalReferenceProvider;
use FRUIT\FlRealurlImage\Provider\FileProvider;
use FRUIT\FlRealurlImage\Provider\PageProvider;
use FRUIT\FlRealurlImage\Provider\TypoScriptProvider;
use FRUIT\FlRealurlImage\Provider\VhsPictureProvider;
use FRUIT\FlRealurlImage\Provider\ViewHelperProvider;
use TYPO3\CMS\Core\Cache\CacheManager;
use TYPO3\CMS\Core\Resource\File;
use TYPO3\CMS\Core\Resource\FileReference;
use TYPO3\CMS\Core\Utility\GeneralUtility;
use TYPO3\CMS\Core\Utility\MathUtility;
use TYPO3\CMS\Core\Utility\PathUtility;
use TYPO3\CMS\Core\Utility\ArrayUtility;
use TYPO3\CMS\Extbase\Configuration\ConfigurationManagerInterface;
use FRUIT\FlRealurlImage\Xclass\Frontend\ContentObject\ContentObjectRenderer;

/**
 * The main class of fl_realurl_image
 */
class RealUrlImage extends ContentObjectRenderer
{

    /**
     * IMAGE-Object config
     *
     * @var array
     */
    protected $IMAGE_conf = [];

    /**
     * @var ContentObjectRenderer
     */
    protected $currentCobj = null;

    /**
     * config.fl_realurl_image from setup.txt / TypoScript merged with IMAGE-Object.fl_realurl_image
     *
     * @var array
     */
    protected $fl_conf = [];

    /**
     * image Array of Typo3
     *
     * @var array
     */
    protected $image = [];

    /**
      - 0: Height
      - 1: Weight
      - 2: Type-Ending
      - 3: File-Name generated by Typo3 (typo3temp/pics/2355fb8381.jpg (after changing, cropping, ...)
      - origFile: fileadmin/series/advanced-a-series/18__Urdhva_Kukkutasana_A.JPG (before changing, cropping, ...)
      - origFile_mtime: 1249081200
      - fileCacheHash: ed0180473f
     */
    protected $fileTypeInformation = [];


    protected $new_fileName = '';

    protected $org_fileName = '';

    protected $enable = true;

    protected Configuration $configuration;
    private EventDispatcherInterface $eventDispatcher;

    /**
     * Outputting the image that fits to the realurl_image request
     * Notice: normally the image should be in the static file cache
     * ... so this is an emergency action only when no image is in static file cache
     * -> to do
     * 1) outputting image
     * 2) recreate the static file cache
     * 3) updating the DB-Entry
     *
     * @return void
     */
    public function showImage()
    {
        // Path of the requested image
        $path = str_replace(GeneralUtility::getIndpEnv('TYPO3_SITE_URL'), '', (string) GeneralUtility::getIndpEnv('TYPO3_REQUEST_URL'));
        $path = trim($path, '/');
        $cacheIdentifier = $path;
        // look up in DB-table if there is a image stored for this realurl
        $cache = $this->getCache();
        if ($cache->has($cacheIdentifier)) {
            // get the information to the requested image
            $data = unserialize($cache->get($cacheIdentifier), FALSE);
            // update DB to idicate that image was requested
            if (!strstr((string) $data['page_id'], '?')) {
                $page_id = trim($data['page_id'] . ',?', ',');
            } else {
                $page_id = trim((string) $data['page_id'], ',');
            }
            $data['tstamp'] = time();
            $data['page_id'] = $page_id;

            $cache->set($cacheIdentifier, serialize($data));

            // linkStatic is switched on, then relink the image static.
            // The obviously lost image will be shown much faster next time
            if ($this->configuration->get('fileLinks')) {
                $this->createFileCache($data['image_path'], $data['realurl_path']);
                $this->eventDispatcher->dispatch(
                    new FileCacheEvent($data['image_path'], $data['realurl_path'])
                );
            }
            // cacheControl is switched on and the image has not been modified since last request
            // => loaded from browser cache
            if ($this->configuration->get('cacheControl') && $_SERVER['HTTP_IF_MODIFIED_SINCE']) {
                $lastGet = strtotime((string) $_SERVER['HTTP_IF_MODIFIED_SINCE']);
                if ($data['tstamp'] != 0 && $lastGet <= $data['tstamp']) {
                    header('HTTP/1.1 304 Not Modified');
                    die();
                }
            } // send headers for image and output the image
            // this is the "manual" way to display an image
            else {
                $info = getimagesize(Environment::getPublicPath() . '/' . $data['image_path']);
                header('Content-Type: ' . $info['mime']);
                header('Content-Length: ' . filesize(Environment::getPublicPath() . '/' . $data['image_path']));
                if ($this->configuration->get('cacheControl') && $data['tstamp'] != 0) {
                    header('Last-Modified: ' . gmdate('D, d M Y H:i:s', $data['tstamp']) . ' GMT');
                }
                readfile(Environment::getPublicPath() . '/' . $data['image_path']);
                die();
            }
        }
        // no image available => die empty - continue page processing
    }

    /**
     * Add the absrefprefix
     *
     * @param $url
     *
     * @return string
     */
    public function addAbsRefPrefix($url)
    {
        if (str_contains((string) $url, 'http://') || str_contains((string) $url, 'https://')) {
            return $url;
        }
        return htmlspecialchars((string) $GLOBALS['TSFE']->absRefPrefix) . ltrim((string) $url, '/');
    }

    /**
     * main function of tx_flrealurlimage class
     *
     * @param array $conf IMAGE-Object configuration array
     * @param array $info image info array:
     *
     * @param null $cObj
     * @return string
     */
    public function main(array $conf, array $info, mixed $file = null, $cObj = null)
    {
        $this->initConfiguration();
        $this->eventDispatcher = GeneralUtility::makeInstance(EventDispatcherInterface::class);

        if($file instanceof FileReference)
        {
            $this->init($conf, $info, $file, $cObj);
            if ($this->enable && trim((string) $this->org_fileName) !== '') {
                $new = $this->generateFileName();
                if ($new !== '') {
                    return $new;
                }
            }
        }
        if($file instanceof File)
        {
            $this->org_fileName = $file->getPublicUrl();
        }

        return $this->org_fileName;
    }

    /**
     * initializing tx_flrealurlimage class
     *
     * @param array $conf IMAGE-Object configuration array
     * @param array $image image info array:
     *
     * @param       $cObj
     */
    protected function init(array $conf, array $image, FileReference $file, ContentObjectRenderer $cObj = null)
    {
        // IMAGE_conf
        $this->IMAGE_conf = $conf;
        $this->currentCobj = $cObj;

        // fl_conf
        $configurationManager = GeneralUtility::makeInstance(ConfigurationManagerInterface::class);
        $settings = $configurationManager->getConfiguration(ConfigurationManagerInterface::CONFIGURATION_TYPE_FULL_TYPOSCRIPT);
        $this->fl_conf = GeneralUtility::removeDotsFromTS($settings['config.']['fl_realurl_image.'] ?? []);
        $local_conf = $conf['fl_realurl_image.'] ?? [];
        ArrayUtility::mergeRecursiveWithOverrule($this->fl_conf, $local_conf);

        // image Array
        $this->image = $image;

        // filetype
        $this->fileTypeInformation = $image;
        $this->enable = (bool)($this->fl_conf['enable'] ?? 0);

        $this->new_fileName = $file->getProperty('realurl_image_name');
        if($this->new_fileName === '' || $this->new_fileName === 'off')
        {
            $this->enable = false;
        }

        // org_fileName
        $this->org_fileName = urldecode((string) $image[3]);
    }

    public function initConfiguration(): void
    {
        $this->configuration = GeneralUtility::makeInstance(Configuration::class);
    }

    /**
     * The main function of fl_realurl_image
     * - generates $this->new_fileName
     * - writes in DB
     * - create static file caches
     *
     * @return        string       the new file name
     */
    protected function generateFileName()
    {
        // generate a text basis for a speaking file name
        if ($this->fl_conf['data'] && $this->new_fileName === '') {
            $this->new_fileName = $this->generateTextBase();
        }
        if ($this->new_fileName === '') {
            return $this->new_fileName;
        }
        unset($this->fl_conf['data']); // important otherwise stdWrap overwrites so far generated new_fileName
        // if $textBase is already a filename then get only the name itself with no path or ending
        if (strstr((string) $this->new_fileName, '/')) {
            $this->new_fileName = basename((string) $this->new_fileName);
        }
        if (strstr((string) $this->new_fileName, '.')) {
            $this->new_fileName = str_replace([
                '.jpg',
                '.JPG',
                '.jpeg',
                '.JPEG',
                '.png',
                '.PNG',
                '.gif',
                '.GIF',
                '.webp'
            ], '', (string) $this->new_fileName);
        }
        // make this text basis suitable for a file name
        $this->new_fileName = $this->smartEncoding($this->new_fileName);
        // add the folder
        $this->new_fileName = $this->fl_conf['folder'] . '/' . $this->new_fileName;
        // add hash and ending = find a not occupied file name
        $this->new_fileName = $this->addHash($this->new_fileName);
        $this->new_fileName = $this->writeDBcollisionHandling($this->new_fileName);
        // delete the old file cache if new image is different to old
        $this->deleteFileCache($this->org_fileName, $this->new_fileName);
        // create the new file cache
        $this->createFileCache($this->org_fileName, $this->new_fileName);

        $this->eventDispatcher->dispatch(
            new FileCacheEvent($this->org_fileName, $this->new_fileName)
        );

        return $this->virtualPathRemove($this->new_fileName);
    }

    /**
     * generates a text Base for generation of a speaking file name
     *
     * @return        string       Text name base
     */
    protected function generateTextBase()
    {
        $configurations = $this->getConfigurationValues();
        $baseInformation = [
            'image' => $this->image,
            'fileTypeInformation' => $this->fileTypeInformation,
            'IMAGE_conf' => $this->IMAGE_conf,
            'cObj' => $this->getCObj(),
        ];

        $providers = [
            new VhsPictureProvider($baseInformation),
            new FalProvider($baseInformation),
            new PageProvider($baseInformation),
            new FalMetaProvider($baseInformation),
            new ViewHelperProvider($baseInformation),
            new FalReferenceProvider($baseInformation),
            new TypoScriptProvider($baseInformation),
            new FileProvider($baseInformation),
        ];

        foreach ($configurations as $configuration)
        {
            $item = $configuration['config'];

            foreach ($providers as $provider) {
                /** @var $provider AbstractProvider */
                if ($provider->getProviderIdentifier() === $configuration['source']) {
                    $value = $provider->getProviderInformation($item);
                    if (strlen((string) $value)) {
                        return $value;
                    }
                }
            }
        }
        return '';
    }

    /**
     * Get configurations
     *
     * @return array
     */
    protected function getConfigurationValues()
    {
        $configurations = [];
        $parts = GeneralUtility::trimExplode('//', $this->fl_conf['data'], true);
        $partSize = sizeof($parts);
        for ($i = 0; $i < $partSize; $i++) {
            $innerParts = GeneralUtility::trimExplode(':', $parts[$i], true);
            $configurations[] = [
                'source' => array_shift($innerParts),
                'config' => implode(':', $innerParts),
            ];
        }
        return $configurations;
    }

    /**
     * Get a valid cObj
     *
     * @return ContentObjectRenderer
     */
    protected function getCObj()
    {
        if (is_object($this->currentCobj)) {
            return $this->currentCobj;
        }
        return GeneralUtility::makeInstance(ContentObjectRenderer::class);
    }

    /**
     * Convert a a text to something that can be used as a file name:
     * - Convert spaces to underscores
     * - Convert non A-Z characters to ASCII equivalents
     * - Convert some special things like the 'ae'-character
     * - Strip off all other symbols
     * - pass through rawurlencode()
     * Works with the character set defined as "forceCharset"
     *
     * @param       string $textBase a text string to encode into a nice file name
     *
     * @return      string      Encoded text string
     * @see rootLineToPath()
     */
    protected function smartEncoding($textBase)
    {
        // decode $textBase
        $textBase = urldecode($textBase);
        // stdWrap
        $textBase = $this->stdWrap($textBase, $this->fl_conf);
        // Convert some special tokens to the space character:
        $space = '-';
        if ($this->fl_conf['spaceCharacter']) {
            $space = $this->fl_conf['spaceCharacter'];
        }
        // spaceCharacter
        $textBase = strtr($textBase, ' -+_', $space . $space . $space);

        // smartEncoding
        if ($this->fl_conf['smartEncoding']) {
            $charset = $GLOBALS['TYPO3_CONF_VARS']['BE']['forceCharset'] ?? $GLOBALS['TSFE']->defaultCharSet;

            if (is_null($charset)) {
                $charset = 'utf-8';
            }
            $textBase = GeneralUtility::makeInstance(CharsetConverter::class)->specCharsToASCII($charset, $textBase);
            // Convert extended letters to ascii equivalents
            $textBase = preg_replace('/[^a-z0-9\/\\\]/i', (string) $space, $textBase); // replace the rest with $space
        }

        // spaceCharacter
        $textBase = preg_replace('/[\/\\' . $space . ']+' . '/i', (string) $space, (string) $textBase); // Convert multiple $space to a single one
        $textBase = trim($textBase, $space); // trim $space
        // encoded $textBase
        return rawurlencode($textBase);
    }

    /**
     * add a very simple Hash to $textBase
     *
     * @param        string $textBase Text base: e.g. typo3temp/fl_realurl_image/myimage-name
     *
     * @return        string        Text base: e.g. typo3temp/fl_realurl_image/myimage-name-a7r
     */
    protected function addHash($textBase)
    {
        if (isset($this->image[3]) && strlen((string) $this->image[3])) {
            $hashBase = substr(md5((string) $this->image[3]), 0, 24);
        } else {
            $hashBase = PathUtility::pathinfo($this->org_fileName, PATHINFO_BASENAME);
        }
        $hashLength = isset($this->fl_conf['hashLength']) ? MathUtility::forceIntegerInRange(
            (int)$this->fl_conf['hashLength'],
            0,
            strlen((string) $hashBase)
        ) : 0;
        if ($hashLength) {
            $textBase .= $this->getSpaceCharacter() . substr((string) $hashBase, 0, $hashLength);
        }
        return $textBase . '.' . PathUtility::pathinfo($this->org_fileName, PATHINFO_EXTENSION);
    }

    /**
     * Return the Space character
     *
     * @return string
     */
    protected function getSpaceCharacter()
    {
        if (isset($this->fl_conf['spaceCharacter']) && strlen((string) $this->fl_conf['spaceCharacter'])) {
            return $this->fl_conf['spaceCharacter'];
        }
        return '-';
    }

    /**
     * Writes $textBase in the fl_realurl_image_cache table
     * arter collissions handling
     *
     * @param string $textBase the path of the new image
     *
     * @return string|NULL the path of the new image after collision handling
     */
    protected function writeDBcollisionHandling($textBase)
    {
        [$trunk, $ending] = explode('.', $textBase);
        $count = '';
        $cache = $this->getCache();
        while (1) {
            if ($this->fl_conf['hashLength'] && $count && $count > 0) {
                $space = '-';
                if ($this->fl_conf['spaceCharacter']) {
                    $space = $this->fl_conf['spaceCharacter'];
                }
            } else {
                $space = '';
            }
            $newImageName_probe = $trunk . $space . $count . '.' . $ending;

            if (!$cache->has($newImageName_probe)) {
                $this->writeDB($newImageName_probe);
                return $newImageName_probe;
            } else {
                // go count one up to avoid collision
                if ($count === '') { // Set count to 0 when run once
                    $count = 0;
                } else {
                    $count++;
                }
            }
        }
    }

    /**
     * Writes in the DB - if not taken
     *
     * @param        string $new_fileName the path to write in the DB
     *
     * @return        boolean        successfull?
     */
    protected function writeDB($new_fileName)
    {
        $cache = $this->getCache();
        $cacheIdent = $this->org_fileName;
        $currentPage = $this->getTypoScriptFrontendController()->id;
        if ($cache->has($cacheIdent)) {
            $data = $cache->get($cacheIdent);
            $pids = GeneralUtility::intExplode(',', (string)$data['page_id'], true);
            if (!in_array($currentPage, $pids)) {
                $pids[] = $currentPage;
            }
            $data['tstamp'] = time();
            $data['page_id'] = implode(',', $pids);
        } else {
            $data = [
                'crdate' => time(),
                'tstamp' => time(),
                'image_path' => $this->org_fileName,
                'new_path' => $new_fileName,
                'page_id' => $currentPage
            ];
        }
        $cache->set($cacheIdent, serialize($data));
        return true;
    }

    /**
     * Deleting the old image in the fl_realurl_image file cache
     * if it is different from the original image.
     * A new, different image has to take this place later and will carie it's name
     *
     * @param        string $org_path the path to the original image e.g.: typo3temp/pics/2305e38d9c.jpg
     * @param        string $new_path the path to the new image
     */
    protected function deleteFileCache($org_path, $new_path)
    {
        if (!Environment::isWindows()) {
            $new_path = Environment::getPublicPath() . '/' . $new_path;
            $org_path = Environment::getPublicPath() . '/' . $org_path;
        }

        if (is_file($new_path) && is_file($org_path)) {
            if (md5_file($new_path) != md5_file($org_path)) {
                unlink($new_path);
            }
        }
    }

    /**
     * creates a hard-link / sym-link / copy of the oritinal image to the new location
     *
     * @param string $relativeOriginalPath the path to the original image e.g.: typo3temp/pics/2305e38d9c.jpg
     * @param string $relativeNewPath the path to the new image
     *
     * @throws \Exception
     */
    public function createFileCache(string $relativeOriginalPath, string $relativeNewPath): void
    {
        $publicPath = $_SERVER['DOCUMENT_ROOT']; // Environment::getPublicPath() is not enough for building symlinks, so we use document root instead
        $relativeOriginalPath = $this->cleanRelativePath($relativeOriginalPath);
        $relativeNewPath = $this->cleanRelativePath($relativeNewPath);

        $absoluteOriginalPath = $publicPath . $relativeOriginalPath;

        if (!is_file($absoluteOriginalPath)) {
            $relativeOriginalPath = rawurldecode($relativeOriginalPath);
            $absoluteOriginalPath = GeneralUtility::getFileAbsFileName($relativeOriginalPath);
            // error no valid $relativeOriginalPath
            if (!is_file($absoluteOriginalPath)) {
                return;
            }
        }

        if ($this->configuration->get('fileLinks') == 'none') {
            return;
        }

        $absoluteNewPath = $publicPath . $relativeNewPath;
        if (is_file($absoluteNewPath) || is_link($absoluteNewPath)) {
            return;
        }

        // Better to throw a exception to find the mistake?!?!
        if (empty($relativeOriginalPath)) {
            return;
        }

        // create folder if required
        $new_folder = $publicPath . GeneralUtility::dirname($relativeNewPath);
        if ($new_folder && !is_dir($new_folder)) {
            if (!GeneralUtility::mkdir($new_folder)) {
                throw new \Exception('Can\'t create the fl_realurl_image Folder "' . $new_folder . '"');
            }
        }
        $indexFile = rtrim((string) $new_folder, '/') . '/index.html';
        if (!is_file($indexFile)) {
            touch($indexFile);
        }
        if (Environment::isWindows()) {
            if ($this->configuration->get('fileLinks') == 'copy') {
                copy($relativeOriginalPath, $absoluteNewPath);
            } else {
                // symlink is not possible
                exec('fsutil hardlink create "' . $relativeNewPath . '" "' . $relativeOriginalPath . '"');
            }
        } else {
            if ($this->configuration->get('fileLinks') == 'copy') {
                copy($absoluteOriginalPath, $absoluteNewPath);
            } elseif ($this->configuration->get('fileLinks') == 'symLink') {
                symlink($absoluteOriginalPath, $absoluteNewPath);
            } else {
                link($relativeOriginalPath, $absoluteNewPath);
            }
        }
    }

    /**
     * Removing a part from the path
     *
     * @param        string $path the path
     *
     * @return        string      the path after removing
     */
    protected function virtualPathRemove($path)
    {
        if ($this->configuration->get('virtualPathRemove')) {
            return str_replace($this->configuration->get('virtualPathRemove'), '', $path);
        }
        return $path;
    }

    /**
     * Get the static file cache
     *
     * @return FrontendInterface
     * @throws NoSuchCacheException
     */
    protected function getCache()
    {
        static $cache = null;
        if ($cache !== null) {
            return $cache;
        }
        $cacheManager = GeneralUtility::makeInstance(CacheManager::class);
        $cache = $cacheManager->getCache('fl_realurl_image');
        return $cache;
    }

    /**
     * @param $textBase
     * @param $fl_conf
     *
     * @return string
     */
    public function stdWrapDummy($textBase, $fl_conf)
    {
        $objectContentRender = new ContentObjectRenderer();
        return $objectContentRender->stdWrap($textBase, $this->fl_conf);
    }
}
